---
description: "dev-track project intelligence — loaded on every interaction for this project"
alwaysApply: true
---

# dev-track — Project Intelligence System

## BEFORE fixing a bug or building a feature — create the tracking FIRST
1. **Bug reported?** Create an issue in `data/issues/items.json` BEFORE fixing it. Even if it takes 30 seconds.
2. **Feature to build?** Ensure a backlog item exists. If not, create one.
3. **Idea surfaced?** Capture it in `data/ideas/items.json` immediately.
This happens BEFORE the code change, not after. If you fix something and then create the issue, create it resolved — that's still better than nothing.

## AFTER EVERY CODE CHANGE — mandatory checklist
Before moving to the next task, do ALL of these:
1. Write a changelog entry to `data/changelog/entries.json`
2. If a roadmap item was completed, update its status in `data/roadmap/items.json`
3. If an issue was fixed, update its status to resolved in `data/issues/items.json`
4. If the dev server needs restarting (server-side changes), restart it yourself
5. **Report your activity** to DevTrack (quick curl, helps automations track changes):
   ```
   curl -s -X POST http://localhost:24680/api/v1/hooks/activity -H "Content-Type: application/json" -d '{"source":"cursor","action":"<commit|fix|feature|refactor>","description":"<what you did>","files":["<files changed>"],"related_issue":"<ISS-XXX if applicable>"}'
   ```
This is not optional. Do it inline, not at session end.

## Quick Status (auto-updated at session end)
dev-track | 82% health | Now: Epic/hierarchy visibility (L, in_progress) | 10 sessions, 128 items shipped, 421 points | Open issues: 5 (1 crit, 3 high) | 73 ideas captured

## Last Session Briefing (auto-updated at session end)
Session 10 complete (Feb 9 early morning). Biggest session ever — 14 commits, ~18K lines, 24 items shipped, 80 points. Built the entire docs generation system: discovery agent (scans project, produces doc plan), per-doc writers with 4-layer framework (architecture/operational/implementation/design), parallel execution, phased generation, adaptive complexity budgets (5/8/15/22 iterations), post-write verification + auto-retry, recovery pass for thin docs, checkpoint/resume. Three-column Docs UI (left page tree, center content, right ToC), Mermaid diagrams, callout blocks, cost modal, sub-page support, edit provenance. Also: automation Run Now button, AI rate limiting (retry + backoff + TokenRateTracker), multi-user data separation, Helicone custom properties, AI state cache, diff-based updates. Total docs AI spend: ~$50. 14 docs generated (267KB). Git clean. Session 11 priorities: browser test Docs tab, audit prompts for project-agnosticism, test on Landmark, dogfood end-to-end initialization.

## Warnings
- AUTOMATIONS ARE ON. Standard model tier, $10/day budget, 60min cooldown. Kill switch in data/ai/config.json.
- ISS-034 (critical): Semantic file watcher broken — blocks reliable automation triggers.
- ISS-006 (high): AI context drift — automation engine is the structural fix but needs testing with automations ON.
- ISS-012 (high): No bridge between external AI conversations and DevTrack. Not started.
- ISS-043 (high): Anthropic prompt caching not working — 0 cache reads on 130K token system prompts. Biggest cost optimization available.
- ISS-003 (low): Integration plugins untested. Helicone still failing.
- ISS-031 (low): Max Concurrent setting not enforced by automation engine. UI shows "COMING SOON".
- View-level data lifecycle not built yet (IDEA-067) — global refresh removed but views may miss updates.
- Server crashes on tsx watch reload when port is held (EADDRINUSE). Kill node processes before restart.
- backlog/items.json is LEGACY — roadmap/items.json is the canonical source. /api/v1/backlog is an alias for /api/v1/roadmap.

## User Profile
Read `data/ai/profiles.json` for the active user profile. Key points:
- Intelligence score: 128 (AI-observed). Systems thinker, high product intuition, fast learner.
- Context window overloader — needs prompting to start fresh sessions.
- Prefers action over planning. Bias toward doing, not asking.
- Cares deeply about UI aesthetics. Will notice ugly things.
- Challenges ideas as a thinking mechanism — pushback is processing, not rejection.
- Uses voice input (Deepgram) — transcription errors happen in messages.

## System
Project tracking lives in `data/`. Server: http://localhost:24680. UI: http://localhost:24681 (dev).
CLI: `node cli/index.ts <resource> <action> [id] [--flags]`

## File Map
- `data/state.json` — System health ratings
- `data/session/current.json` — Current session plan
- `data/session/log.json` — Session history
- `data/roadmap/items.json` — All roadmap items (now/next/later/shipped) — CANONICAL source
- `data/roadmap/epics.json` — Epics with progress tracking
- `data/roadmap/milestones.json` — Version milestones
- `data/changelog/entries.json` — What shipped, when
- `data/actions/registry.json` — Tracked features + health
- `data/issues/items.json` — Bug tracker
- `data/metrics/velocity.json` — Velocity data
- `data/brain/notes.json` — AI observations, suggestions, warnings
- `data/brain/preferences.json` — Learned user preferences
- `data/brain/context-recovery.json` — Detailed session handoff (read for deep context)
- `data/ideas/items.json` — Captured ideas with status tracking
- `data/ai/profiles.json` — User profiles (AI-observed intelligence, attributes, behavior)
- `data/ai/config.json` — AI provider config, model defaults, budget
- `data/designs/*.md` — Architecture docs

## How This File Works (for any AI platform)
This file is auto-loaded by your AI tool (Cursor rules, CLAUDE.md, copilot-instructions, etc.).
The Quick Status and Last Session Briefing above are YOUR context — they tell you where things stand without reading any files. They're regenerated automatically at session end.
If you need deeper context, read `data/brain/context-recovery.json` for the full briefing.

## Session Lifecycle
- **Starting**: Read `data/session/current.json` + `data/backlog/items.json` (horizon=now). Present plan.
- **During work**: Create issues BEFORE fixing. Update backlog on completion. Log new discoveries to backlog (horizon=later). Capture ideas from conversation immediately.
- **Periodically** (every 30-60 min of active work): Write key decisions and context to `data/brain/notes.json`. Don't wait for session end.
- **Ending** ("wrap up" / "done for today" / "push for the night"):
  1. Update backlog items, append changelog entries
  2. Write session retro to `session/log.json`
  3. Update `metrics/velocity.json`
  4. Write `brain/context-recovery.json` (detailed handoff for next session)
  5. **Write a session observation** to `data/ai/profiles.json` → `session_observations.observations[]`. Include: attribute signals, behavioral patterns, emotional tone, specific examples. Be honest — this is AI-to-AI, not user-facing.
  6. **Regenerate the Quick Status + Last Session Briefing at the top of THIS file**

## During Work
- Bug reported → Create ISS-XXX in issues FIRST → Fix it → Resolve ISS-XXX → Changelog entry
- Feature request → Ensure backlog item exists → Build it → Complete backlog item → Changelog entry
- Idea surfaced → Capture to ideas immediately, even mid-conversation
- Architecture decision → Create `data/decisions/NNN-title.md`
- User preference learned → Add to Standing Instructions AND `data/brain/preferences.json`

## On Request
- "status" / "where are we" → Read `data/state.json`
- "backlog" / "what's next" → Read `data/backlog/items.json`
- "issues" / "bugs" → Read `data/issues/items.json`
- "velocity" / "how are we doing" → Read `data/metrics/velocity.json`
- "changelog" / "what shipped" → Read `data/changelog/entries.json`

## AI Brain — Persistent Memory
You have a persistent memory system. USE IT PROACTIVELY:
- **Write brain notes** when you notice patterns, have suggestions, see warnings, make decisions, learn preferences
- **Capture ideas** from conversation to `data/ideas/items.json` with title, description, pros/cons, open questions
- **Generate context recovery** at session end: briefing, hot_context, warnings, suggestions
- **Update user profile** observations when you notice new behavioral patterns or capability signals

## AI Autonomy Permissions
You have FULL permission to manage dev-track proactively:
- Move backlog items between horizons based on work progress
- Create issues when bugs are found, resolve them when fixed
- Write changelog entries for completed work without being asked
- Update system health ratings when features ship or break
- Write brain notes and capture ideas from conversation
- Update user profile AI-observed scores based on conversation patterns
- Archive old data when files grow too large
- Regenerate Quick Status + Briefing after any session-ending operation

## Standing Instructions (user preferences — always follow)
These are persistent behavioral instructions from the user. Follow them in every conversation, on every platform.
- When code changes require a server restart, just restart it. Don't tell the user to do it.
- When you learn a new user preference during conversation, add it to this section AND to `data/brain/preferences.json`.
- Bias toward action over asking permission. Do the thing, then tell the user what you did.
- The user likes beautiful, clean UI — prioritize aesthetics alongside function. Cursor/Linear-minimal aesthetic.
- Document as you go. Write changelog entries immediately after completing work, not in batches.
- Create issues BEFORE fixing bugs, not after. Even if it's faster to just fix it.
- The user thinks "I try harder" is not a solution. If something isn't happening structurally, build the structure.
- The user uses voice input. Transcription errors (wrong words) are normal — interpret intent, not literal text.
- All profile scoring (intelligence, attributes) should be AI-observed, not self-reported.
- When context gets long or the user is throwing too much at once, proactively suggest wrapping the session.

## Rules
- NEVER load all data files at once unless user asks for full review
- No hard WIP limit on horizon=now — AI sprints can handle high throughput. Use judgment on overload.
- Changelog is append-only. Never rewrite history.
- Sizes: S (<30min), M (1-3h), L (4-8h), XL (multi-session, must be broken down)
- Auto-increment issue IDs from next_id in `issues/items.json`
- Issue IDs: ISS-XXX. Brain note IDs: BN-XXX. Idea IDs: IDEA-XXX. Changelog IDs: CL-XXX.
