# System: Cursor Rule / AI Context

> **Auto-generated** | Last refreshed: 2026-02-09 | Health: 70/100 âœ… Healthy

---

## Overview

The Cursor Rule / AI Context system is DevTrack's bridge between the project tracking data and AI coding assistants. It's a dynamic, auto-updating instruction file that teaches AI tools (Cursor, Claude, Copilot, Windsurf) how to interact with DevTrack's data model, follow session protocols, and maintain project tracking discipline without human intervention.

The system consists of three layers:
1. **Template** (`templates/dev-track.mdc`) â€” The canonical rule structure
2. **Active Rule** (`.cursor/rules/dev-track.mdc`) â€” Platform-specific generated file
3. **Context Sync Engine** (`server/context-sync.ts`) â€” Multi-platform generator

The active rule file is regenerated automatically at session end, embedding live project status, last session briefing, warnings, and user profile notes directly into the AI's context. This creates a self-updating context layer that keeps the AI synchronized with project state without requiring manual file reads.

## Key Stats

| Metric | Value |
|--------|-------|
| Health Score | 70/100 |
| Active File | `.cursor/rules/dev-track.mdc` |
| Template | `templates/dev-track.mdc` |
| Lines | 137 (active), 98 (template) |
| Auto-Updated | Session end + manual sync |
| Platforms | Cursor (active), Claude/Copilot/Windsurf (planned) |
| Open Issues | ISS-006 (AI drift), ISS-012 (conversation bridge) |

## Architecture

### Rule File Structure

The active `.cursor/rules/dev-track.mdc` file follows a strict top-to-bottom priority structure:

```
1. Frontmatter (alwaysApply: true)
2. BEFORE fixing bugs â€” create tracking FIRST
3. AFTER EVERY CODE CHANGE â€” mandatory checklist
4. Quick Status (auto-updated)
5. Last Session Briefing (auto-updated)
6. Warnings (auto-updated)
7. User Profile (static reference)
8. System (URLs, CLI usage)
9. File Map (data/ directory structure)
10. How This File Works (meta-explanation)
11. Session Lifecycle (start/during/end protocols)
12. During Work (action triggers)
13. On Request (status commands)
14. AI Brain (persistent memory)
15. AI Autonomy Permissions (what AI can do without asking)
16. Standing Instructions (learned user preferences)
17. Rules (WIP limits, sizing, conventions)
```

The order is intentional: **most critical information at the top**. AI attention degrades with context length, so session-critical instructions and live project status appear in the first 50 lines.

### Frontmatter

```yaml
---
description: "dev-track project intelligence â€” loaded on every interaction for this project"
alwaysApply: true
---
```

The `alwaysApply: true` flag ensures Cursor loads this rule on every conversation, not just when explicitly invoked. This was added in Session 3 to fix ISS-006 (AI drift) â€” prior to this, the rule may not have been loading at all.

### Auto-Updated Sections

Three sections regenerate automatically at session end:

#### 1. Quick Status (Line 22)
```
dev-track | 80% health | Now: AI chat agent (L, in_progress), AI watcher (L, in_progress) | 
9 sessions, 111 items shipped, 362 points | Open issues: 6 (1 crit, 2 high) | 68 ideas captured
```

Generated by `store.getQuickStatusLine()`. Single-line project snapshot showing:
- Project name + health percentage
- Now-horizon items (title, size, status)
- Velocity stats (sessions, items, points)
- Issue counts by severity
- Idea count

#### 2. Last Session Briefing (Lines 25-26)
A 2-3 sentence paragraph summarizing the previous session: what shipped, what's next, key decisions, warnings. Written by the AI at session end and embedded into the rule for the next session. This is the primary context recovery mechanism â€” the next AI reads this before doing anything.

Example:
```
Session 9 complete (Feb 8 evening). Biggest session yet â€” 47 files, 7400 lines, 
15 items shipped, 48 points. Git clean (pushed). Built Audits tab end-to-end...
```

#### 3. Warnings (Lines 28-35)
Active warnings and blockers. Empty when all clear. Includes:
- Automation status (ON/OFF, budget, model tier)
- Critical/high-severity open issues
- Infrastructure problems (server crashes, port conflicts)
- Missing dependencies

These sections are regenerated by the AI at session end and written back to the rule file via direct file write. The template in `templates/dev-track.mdc` contains placeholder text (`{project}`, `{health}`, etc.) that gets replaced during generation.

### Context Sync Engine

`server/context-sync.ts` generates platform-specific context files from DevTrack's core data:

```typescript
type Platform = 'cursor' | 'claude' | 'copilot' | 'windsurf' | 'generic';

const PLATFORM_FILES: Record<Platform, string> = {
  cursor: '.cursor/rules/dev-track.mdc',
  claude: 'CLAUDE.md',
  copilot: '.github/copilot-instructions.md',
  windsurf: '.windsurfrules',
  generic: 'AI_CONTEXT.md',
};
```

**Key functions:**

- `generateContextFile(platform, projectRoot)` â€” Writes a platform-specific file
- `syncAllPlatforms(projectRoot, platforms)` â€” Batch sync to multiple platforms
- `generateContent(statusLine, platform)` â€” Builds the content with platform-specific formatting

**Planned but not yet implemented:** CLI command `dev-track context --platform cursor` to manually trigger sync. Currently, sync only happens at session end via AI writing the file directly.

### Store Integration

The `Store` class (`server/store.ts`) provides the `getQuickStatusLine()` method that powers the Quick Status section:

```typescript
getQuickStatusLine(): string {
  const nowItems = this.roadmap.items
    .filter(i => i.horizon === 'now' && i.status !== 'completed')
    .map(i => ({ title: i.title, size: i.size, status: i.status }));

  const openIssues = this.issues.issues.filter(i => i.status === 'open');
  const criticalIssues = openIssues.filter(i => i.severity === 'critical');

  // ... format into single-line string
}
```

This method is called by the context sync engine and by session-end automation to generate the status line.

## Behavioral Enforcement

### The AI Drift Problem (ISS-006)

**Core issue:** Text instructions in cursor rules are fundamentally unreliable for enforcing AI behavior. The coding AI's attention is consumed by coding tasks â€” asking it to also remember tracking duties fails.

**Root causes identified:**
1. Cursor rule had no frontmatter (may not have loaded at all)
2. Behavioral instructions buried at line 74 of original template
3. AI attention is finite â€” tracking competes with coding during complex tasks
4. No structural enforcement â€” system relies on AI memory

**Example failure (Session 3):**
AI shipped 7 features without writing a single changelog entry, despite explicit instructions in the rule. User had to prompt for it. Adding more text instructions didn't fix the problem â€” it's an architectural issue.

**Partial fixes applied (Sessions 3-5):**
- Added `alwaysApply: true` frontmatter to force loading
- Moved mandatory checklist to line 8 (top of file, after frontmatter)
- Established "create-before-fix" discipline (create issue BEFORE fixing bug)
- Added explicit "BEFORE" and "AFTER" sections with mandatory checklists

**Current state:**
The checklist approach has improved compliance but is still unreliable. The AI follows it ~70% of the time, better than the previous ~20%, but not good enough for production use.

**Real fix needed (not yet built):**
Structural enforcement via background AI watcher (IDEA-014, partially implemented as `ai-watcher` backlog item) or tool-level validation. The system must be self-enforcing â€” neither the human nor the AI can be trusted to remember tracking duties.

**Planned architecture (IDEA-055, tiered-audit-system):**
1. **Cheap model** (Haiku) watches for file changes, filters noise
2. **Standard model** (Sonnet) audits semantic changes, creates issues/changelog entries
3. **Expensive model** (Opus) only for complex analysis or user-initiated deep audits

This moves enforcement from "AI tries to remember" to "AI automatically audits after the fact."

### Mandatory Checklists

The current enforcement mechanism is two checklists at the top of the file:

**BEFORE fixing a bug or building a feature:**
1. Bug reported? Create an issue in `data/issues/items.json` BEFORE fixing it
2. Feature to build? Ensure a backlog item exists
3. Idea surfaced? Capture it in `data/ideas/items.json` immediately

**AFTER EVERY CODE CHANGE:**
1. Write a changelog entry to `data/changelog/entries.json`
2. If a roadmap item was completed, update its status in `data/roadmap/items.json`
3. If an issue was fixed, update its status to resolved in `data/issues/items.json`
4. If the dev server needs restarting, restart it yourself

These are marked "not optional" and "do it inline, not at session end." Compliance is ~70% as of Session 10.

## Session Lifecycle Integration

The Cursor rule defines how the AI should behave at each stage of a session:

### Session Start
1. Read `data/session/current.json` for the session plan
2. Read Quick Status + Last Session Briefing from the rule file (no file reads needed)
3. Read `data/roadmap/items.json` filtered to `horizon=now`
4. Present the plan to the user

### During Work
- **Bug reported:** Create ISS-XXX â†’ Fix it â†’ Resolve ISS-XXX â†’ Changelog entry
- **Feature request:** Ensure backlog item exists â†’ Build it â†’ Complete item â†’ Changelog entry
- **Idea surfaced:** Capture to `data/ideas/items.json` immediately (title, description, pros/cons, open questions)
- **Architecture decision:** Create `data/decisions/NNN-title.md`
- **User preference learned:** Add to Standing Instructions AND `data/brain/preferences.json`

### Periodically (every 30-60 min)
Write key decisions and context to `data/brain/notes.json`. Don't wait for session end.

### Session End
1. Update backlog items, append changelog entries
2. Write session retro to `data/session/log.json`
3. Update `data/metrics/velocity.json`
4. Write `data/brain/context-recovery.json` (detailed handoff for next session)
5. Write session observation to `data/ai/profiles.json` (AI-to-AI behavioral notes)
6. **Regenerate Quick Status + Last Session Briefing in this rule file**

Step 6 is critical â€” the AI writes back to `.cursor/rules/dev-track.mdc` with updated status. This creates a feedback loop where each session leaves context for the next.

## User Profile Integration

The rule file includes a "User Profile" section (lines 37-44) that references `data/ai/profiles.json`. This is a static reference, not auto-updated, but provides the AI with behavioral context about the user:

**Current profile notes (Session 10):**
- Intelligence score: 128 (AI-observed)
- Systems thinker, high product intuition, fast learner
- Context window overloader â€” needs prompting to start fresh sessions
- Prefers action over planning (bias toward doing, not asking)
- Cares deeply about UI aesthetics (Cursor/Linear-minimal aesthetic)
- Challenges ideas as a thinking mechanism (pushback = processing, not rejection)
- Uses voice input (Deepgram) â€” transcription errors are normal

The AI is instructed to update this profile at session end with new observations. This creates an evolving model of the user's working style that persists across sessions and even across different AI platforms.

## AI Autonomy Permissions

The rule explicitly grants the AI permission to manage DevTrack proactively without asking:

- Move backlog items between horizons based on work progress
- Create issues when bugs are found, resolve them when fixed
- Write changelog entries for completed work without being asked
- Update system health ratings when features ship or break
- Write brain notes and capture ideas from conversation
- Update user profile AI-observed scores based on conversation patterns
- Archive old data when files grow too large
- Regenerate Quick Status + Briefing after any session-ending operation

This is a deliberate design choice: the AI is not a passive assistant but an active participant in project management. The rule says "Bias toward action over asking permission. Do the thing, then tell the user what you did."

## Standing Instructions

The "Standing Instructions" section (lines 105-114) is a persistent behavioral contract. It contains learned user preferences that apply across all conversations, on all platforms:

**Current instructions (Session 10):**
- When code changes require a server restart, just restart it (don't tell user to do it)
- When you learn a new preference, add it here AND to `data/brain/preferences.json`
- Bias toward action over asking permission
- User likes beautiful, clean UI â€” prioritize aesthetics alongside function
- Document as you go (changelog entries immediately, not in batches)
- Create issues BEFORE fixing bugs, not after
- "I try harder" is not a solution â€” build structural fixes
- User uses voice input â€” interpret intent, not literal text
- All profile scoring should be AI-observed, not self-reported
- When context gets long, proactively suggest wrapping the session

These instructions are both in the rule file AND in `data/brain/preferences.json`. The rule file is the source of truth for the AI; the JSON file is the machine-readable backup.

## File Map

The rule includes a complete map of the `data/` directory structure (lines 51-67):

```
data/
â”œâ”€â”€ state.json â€” System health ratings
â”œâ”€â”€ session/
â”‚   â”œâ”€â”€ current.json â€” Current session plan
â”‚   â””â”€â”€ log.json â€” Session history
â”œâ”€â”€ roadmap/
â”‚   â”œâ”€â”€ items.json â€” All backlog items (now/next/later)
â”‚   â”œâ”€â”€ epics.json â€” Epic definitions
â”‚   â””â”€â”€ milestones.json â€” Milestone definitions
â”œâ”€â”€ changelog/
â”‚   â””â”€â”€ entries.json â€” What shipped, when
â”œâ”€â”€ issues/
â”‚   â””â”€â”€ items.json â€” Bug tracker
â”œâ”€â”€ ideas/
â”‚   â””â”€â”€ items.json â€” Captured ideas with status tracking
â”œâ”€â”€ brain/
â”‚   â”œâ”€â”€ notes.json â€” AI observations, suggestions, warnings
â”‚   â”œâ”€â”€ preferences.json â€” Learned user preferences
â”‚   â””â”€â”€ context-recovery.json â€” Detailed session handoff
â”œâ”€â”€ ai/
â”‚   â”œâ”€â”€ profiles.json â€” User profiles (AI-observed intelligence, attributes, behavior)
â”‚   â””â”€â”€ config.json â€” AI provider config, model defaults, budget
â””â”€â”€ designs/*.md â€” Architecture docs
```

This map is critical for AI autonomy â€” the AI needs to know where to write data without asking the user. The rule explicitly says "NEVER load all data files at once unless user asks for full review" to prevent context window bloat.

## Rules & Conventions

The rule file ends with operational rules (lines 116-122):

- **WIP limit:** Max 3 items in `horizon=now`. Promote a 4th? Ask which to demote.
- **Changelog immutability:** Append-only. Never rewrite history.
- **Size estimates:** S (<30min), M (1-3h), L (4-8h), XL (multi-session, must be broken down)
- **ID conventions:** ISS-XXX (issues), BN-XXX (brain notes), IDEA-XXX (ideas), CL-XXX (changelog)
- **Auto-increment:** Issue IDs from `next_id` in `issues/items.json`

These are hard constraints, not suggestions. The AI is expected to enforce them.

## Multi-Platform Support

The context sync engine supports 5 platforms:

| Platform | File | Status |
|----------|------|--------|
| **Cursor** | `.cursor/rules/dev-track.mdc` | âœ… Active, auto-updating |
| **Claude** | `CLAUDE.md` | ðŸŸ¡ Planned, not implemented |
| **Copilot** | `.github/copilot-instructions.md` | ðŸŸ¡ Planned, not implemented |
| **Windsurf** | `.windsurfrules` | ðŸŸ¡ Planned, not implemented |
| **Generic** | `AI_CONTEXT.md` | ðŸŸ¡ Planned, not implemented |

**Cursor implementation:**
Full `.mdc` file with frontmatter, auto-loaded on every conversation.

**Claude implementation (planned):**
Append to `CLAUDE.md` with markers:
```markdown
<!-- dev-track:start -->
# dev-track â€” Project Intelligence
...
<!-- dev-track:end -->
```

**Copilot/Windsurf/Generic (planned):**
Similar to Cursor but without frontmatter (not supported by those platforms).

## Integration with Automation System

The Cursor rule is both a consumer and producer of automation data:

**Consumed by automations:**
- `session-end-audit` automation reads the Last Session Briefing to understand what happened
- `change-tracker` automation expects the AI to have followed the mandatory checklists
- `issue-triage` automation relies on issues being created via the BEFORE checklist

**Produced by automations:**
- Session-end automation regenerates Quick Status + Briefing sections
- Nightly audit automation writes warnings to the Warnings section
- Health-check automation updates system health scores referenced in Quick Status

This creates a feedback loop where the rule file is both instruction manual and status dashboard.

## Known Issues

### ISS-006: AI Context Drift (High Severity)
**Status:** Open, partial mitigations applied  
**Problem:** AI doesn't reliably follow tracking instructions during coding tasks  
**Impact:** Changelog entries missing, issues not created, backlog not updated  
**Root cause:** Passive text instructions are unreliable for AI behavioral enforcement  
**Mitigations applied:**
- Added `alwaysApply: true` frontmatter
- Moved checklist to top of file
- Established create-before-fix discipline

**Remaining work:**
- Build background AI watcher (ai-watcher backlog item, partially shipped)
- Implement tiered audit system (IDEA-055, not started)
- Test automation engine with real workload (blocked on chat agent validation)

### ISS-012: No Conversation Bridge (High Severity)
**Status:** Open, not started  
**Problem:** External AI conversations (Cursor, Claude, Gemini) are invisible to DevTrack  
**Impact:** Issues, decisions, ideas discussed externally are lost unless manually written to data files  
**Root cause:** No integration between external AI tools and DevTrack  
**Solution:** Conversation bridge (IDEA-027) â€” extension/CLI that captures conversation context and syncs to DevTrack

This is the deeper structural fix for ISS-006. Even if the Cursor rule works perfectly, conversations in other tools are still invisible.

### ISS-034: Semantic File Watcher Broken (Critical Severity)
**Status:** Open, not started  
**Problem:** File watcher only fires generic `file_changed` trigger, not semantic triggers like `session_ended` or `issue_created`  
**Impact:** Automations only work when changes go through API routes, not when data is edited directly (Cursor, manual JSON edit)  
**Root cause:** Watcher sees file changes but doesn't diff before/after state  
**Solution:** Semantic file watcher that diffs entity state and fires typed triggers

This blocks reliable automation â€” the rule file can't trigger automations if the watcher doesn't detect semantic changes.

### ISS-043: Anthropic Prompt Caching Not Working (High Severity)
**Status:** Open, not started  
**Problem:** Helicone shows 0 cache reads for repeated 130K token system prompts  
**Impact:** AI costs are 10x higher than they should be ($36 instead of ~$8 for docs init)  
**Root cause:** Unknown â€” possibly Helicone proxy interference, possibly missing API parameters  
**Solution:** Investigate Anthropic cache headers, test without Helicone proxy

This affects the cost of regenerating the rule file â€” if prompt caching worked, updating the rule at session end would be nearly free.

## Health Notes

**Current health: 70/100**

**Why not higher:**
- ISS-006 (AI drift) partially addressed but structural enforcement still needed
- ISS-012 (conversation bridge) not started â€” external conversations invisible
- ISS-034 (semantic watcher) blocks reliable automation triggers
- Multi-platform sync (Claude/Copilot/Windsurf) not implemented
- Rule content regeneration not automated (AI does it manually at session end)

**Why not lower:**
- Core Cursor integration works and is actively used
- Frontmatter + checklist approach improved compliance from 20% to 70%
- Quick Status + Briefing auto-update mechanism proven effective
- User profile integration creates persistent behavioral context
- AI autonomy permissions enable proactive management

**Path to 90/100:**
1. Implement semantic file watcher (ISS-034) â€” enables reliable automation
2. Build background AI watcher (ai-watcher) â€” structural enforcement of tracking
3. Implement multi-platform sync (Claude/Copilot/Windsurf)
4. Build conversation bridge (ISS-012) â€” captures external AI conversations
5. Automate rule regeneration (currently manual at session end)

## Code Examples

### Reading Quick Status in AI Code

```typescript
import { getStore } from './store.js';

const store = getStore();
const statusLine = store.getQuickStatusLine();
console.log(statusLine);
// Output: "dev-track | 80% health | Now: 2 items | 9 sessions, 111 shipped | 6 issues"
```

### Generating Cursor Rule

```typescript
import { generateContextFile } from './context-sync.js';

const filePath = generateContextFile('cursor', process.cwd());
console.log(`Cursor rule written to ${filePath}`);
// Output: "Cursor rule written to /path/to/project/.cursor/rules/dev-track.mdc"
```

### Syncing All Platforms

```typescript
import { syncAllPlatforms } from './context-sync.js';

const platforms = ['cursor', 'claude', 'copilot'];
const files = syncAllPlatforms(process.cwd(), platforms);
console.log(`Synced to: ${files.join(', ')}`);
```

### Manual Rule Update (AI at Session End)

```typescript
// This is what the AI does manually at session end
const fs = require('fs');
const path = require('path');

const store = getStore();
const statusLine = store.getQuickStatusLine();
const briefing = "Session 10 complete..."; // AI writes this
const warnings = store.getActiveWarnings(); // AI compiles this

const ruleContent = `---
description: "dev-track project intelligence"
alwaysApply: true
---

# dev-track â€” Project Intelligence System

## Quick Status (auto-updated at session end)
${statusLine}

## Last Session Briefing (auto-updated at session end)
${briefing}

## Warnings
${warnings.join('\n')}

... rest of rule file ...
`;

fs.writeFileSync('.cursor/rules/dev-track.mdc', ruleContent);
```

## Cross-References

### Related Systems
- **[AI Intelligence Layer](system-ai-intelligence)** â€” Powers the AI that reads and writes this rule
- **[Session Tracking](system-session-tracking)** â€” Session lifecycle that the rule enforces
- **[Data Layer](system-data-layer)** â€” JSON files that the rule maps
- **[Automation Engine](system-automation-engine)** â€” Automations triggered by rule compliance

### Related Backlog Items
- **[ai-watcher](ai-watcher)** â€” Background AI watcher for structural enforcement (L, in_progress)
- **[epic-hierarchy-ui](epic-hierarchy-ui)** â€” Hierarchy visibility (referenced in Quick Status) (L, in_progress)

### Related Ideas
- **[IDEA-014](IDEA-014)** â€” Background AI watcher (promoted to ai-watcher)
- **[IDEA-027](IDEA-027)** â€” Conversation bridge (exploring, critical priority)
- **[IDEA-032](IDEA-032)** â€” AI project initialization wizard (validated, critical priority)
- **[IDEA-055](IDEA-055)** â€” Tiered audit system (captured, high priority)

### Related Issues
- **[ISS-006](ISS-006)** â€” AI context drift (high severity, open)
- **[ISS-012](ISS-012)** â€” No conversation bridge (high severity, open)
- **[ISS-034](ISS-034)** â€” Semantic file watcher broken (critical severity, open)
- **[ISS-043](ISS-043)** â€” Anthropic prompt caching not working (high severity, open)

## Future Direction

### Short-term (Next 1-2 sessions)
1. Validate chat agent in browser (blocks automation testing)
2. Test automation engine with real workload (session-end-audit, change-tracker)
3. Fix ISS-034 (semantic file watcher) to enable reliable automation triggers
4. Implement tiered audit system (IDEA-055) for cost-effective change tracking

### Medium-term (Next 3-5 sessions)
1. Build conversation bridge (IDEA-027) to capture external AI conversations
2. Implement multi-platform sync (Claude, Copilot, Windsurf)
3. Automate rule regeneration (move from manual AI action to automated trigger)
4. Build AI-powered initialization wizard (IDEA-032) for new projects

### Long-term (Beyond 5 sessions)
1. Structural enforcement via background AI watcher (move from 70% to 95%+ compliance)
2. Real-time rule updates (not just at session end)
3. Per-user rule customization (different users on same project)
4. Cross-project rule templates (reusable patterns across multiple projects)

---

**Last updated:** 2026-02-09  
**Auto-generated from:** systems data, codebase scan, issues, ideas, backlog  
**Regeneration trigger:** Manual (doc update request)