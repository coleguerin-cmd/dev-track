# System: Codebase Scanner & Visualizer

> **Auto-generated** | Last refreshed: 2026-02-09 | Scanner: 80/100 | Visualizer: 80/100 ✅ Healthy

---

## Overview

The Codebase Scanner and Visualizer form DevTrack's architecture intelligence layer — a two-part system that automatically analyzes source code and renders it as interactive, plain-English architecture diagrams. Together, they transform a directory of files into a living map of how a codebase works.

**The Scanner** walks your project directory and extracts structural information: files, functions, components, API routes, imports, database operations, and external service calls. It infers logical modules from directory structure, generates plain-English descriptions from code patterns, and builds dependency graphs.

**The Visualizer** takes the scanner's output and renders three interactive graph views using react-flow: Module Architecture (high-level system overview), File Dependencies (import relationships), and API Route Map (endpoints and handlers). Every node has a human-readable description. Every edge has a relationship label. No special code annotations required.

This system powers DevTrack's **layman-friendly architecture visualization** — designed so non-developers can understand what the codebase does and how it connects, without reading code.

---

## Architecture Philosophy

### Zero-Annotation Design (IDEA-017)

Instead of requiring developers to annotate code with special comments like `@dt-description` or `@dt-module`, the scanner is **smart enough to understand code from its existing structure**. This design choice:

- **Avoids code pollution** — no special comments cluttering source files
- **Works across all languages** — analyzes structure, not syntax-specific patterns
- **Makes the code itself the source of truth** — descriptions stay synchronized with reality
- **Produces better descriptions** — inferred from actual behavior (file types, exports, services, DB ops) rather than stale comments

The scanner reads TypeScript/JavaScript files and infers meaning from:
- Directory structure (routes/, components/, integrations/)
- File types (API routes, pages, components, hooks, utilities)
- Export patterns (functions, components, hooks, classes, types)
- Import relationships (who depends on whom)
- External service calls (fetch URLs, SDK usage)
- Database operations (Drizzle, SQL patterns)

### Plain-English Descriptions

Every module and edge gets a **generated description** that explains what it does in layman's terms:

**Module descriptions** (generated by `generateModuleDescription()`):
- "This module handles all the HTTP API endpoints for the application. It contains 22 route files covering: activity, ai, automations, brain, changelog, codebase..."
- "Reusable UI building blocks (14 components). These handle individual pieces of the interface like buttons, panels, cards, and visualizations."
- "Connects to external services (cloudflare, github, helicone, sentry, vercel). Each integration can be configured with API credentials..."

**Edge labels** (generated by `generateEdgeLabel()`):
- "handles API requests" (routes → server)
- "stores data using" (server → data layer)
- "renders UI with" (views → components)
- "fetches data from" (UI → API routes)

This was the fix for **ISS-007** (Architecture graph is meaningless to non-developers) — the original graph showed technical import names but no semantic meaning.

---

## Codebase Scanner

**Location:** `server/analyzer/scanner.ts`  
**Entry point:** `scanCodebase(projectRoot: string, srcDir?: string): Promise<CodebaseAnalysis>`  
**Dependencies:** Node.js fs, path (no external libraries)

### What It Scans

The scanner walks the project directory recursively, skipping common ignore patterns:

```typescript
const SKIP_DIRS = new Set([
  'node_modules', '.next', '.git', 'dist', 'build', '.pglite',
  '.local_storage', 'coverage', '__pycache__', '.cache',
]);

const CODE_EXTENSIONS = new Set(['.ts', '.tsx', '.js', '.jsx', '.mjs', '.cjs']);
```

For each file, it extracts:

| Data | How It's Extracted |
|------|-------------------|
| **File metadata** | Path, name, extension, line count, size |
| **File type** | Classified by path patterns and content analysis |
| **Exports** | Regex patterns for functions, components, hooks, classes, constants, types |
| **Imports** | Named imports, default imports, source paths, external vs local |
| **External calls** | fetch() URLs, SDK patterns (OpenAI, Anthropic, Supabase, etc.) |
| **DB operations** | Drizzle/SQL patterns (.select, .insert, .update, .delete) |

### File Classification

Files are classified into types using a combination of path patterns and content analysis:

```typescript
type FileType = 'page' | 'api_route' | 'component' | 'hook' | 'utility' 
              | 'config' | 'schema' | 'style' | 'test' | 'other';
```

**Classification rules** (`classifyFile()` function):
- **API routes:** Files in `/routes/` or `/api/` dirs, or files with Hono/Express route patterns
- **Pages:** Files ending in `page.tsx`, or in `/views/` or `/pages/` directories
- **Components:** Files in `/components/` or exporting PascalCase functions in .tsx/.jsx
- **Hooks:** Files in `/hooks/` or exporting functions starting with `use[A-Z]`
- **Utilities:** Files in `/lib/`, `/utils/`, `/helpers/`, `/integrations/`
- **Schemas:** Files with `schema` in path or in `/types/` directories
- **Config:** Files ending in `.config.ts/js` or named tsconfig/tailwind/vite.config

### Module Inference

The scanner groups files into **logical modules** based on directory structure:

**Strategy:** Group by the deepest meaningful directory (2-3 levels deep). If a directory has 1-2 files, merge up to parent. If it has many, it's its own module.

**Example module grouping:**
- `server/routes/` → "Server Routes" (22 API route files)
- `server/ai/` → "Server Ai" (21 AI service and tool files)
- `server/integrations/` → "Server Integrations" (10 plugin files)
- `ui/src/views/` → "UI Views" (13 page components)
- `ui/src/components/` → "UI Components" (8 reusable components)

For each module, the scanner calculates:
- **File type summary** — counts by type (e.g., 22 api_route, 8 component, 5 utility)
- **All exports** — every function, component, hook, class exported from the module
- **Key exports** — the most important 8 exports (functions, components, hooks, classes — not types/constants)
- **Dependencies** — other modules this one imports from
- **External services** — external APIs/SDKs used (openai, anthropic, helicone, github, etc.)
- **Description** — generated plain-English explanation of what the module does

### Description Generation

The `generateModuleDescription()` function creates rich, context-aware descriptions by analyzing:

1. **File type composition** — How many routes, components, hooks, utilities, configs?
2. **Directory path** — Does the path contain `/routes/`, `/components/`, `/integrations/`?
3. **Module name** — Does the name suggest its purpose (Server Routes, UI Components)?
4. **Exports** — What are the key functions/components exported?
5. **External services** — Which APIs/SDKs does it use?
6. **Database operations** — Does it perform SELECT, INSERT, UPDATE, DELETE?

**Description templates** (simplified):

```typescript
// API routes module
if (routeCount > 0 && lowerName.includes('route')) {
  parts.push(`This module handles all the HTTP API endpoints for the application.`);
  parts.push(`It contains ${routeCount} route files covering: ${routeNames.slice(0, 6).join(', ')}...`);
  parts.push(`Routes receive HTTP requests, process them, and return JSON responses.`);
  if (hasDb) parts.push(`It reads and writes data to the persistence layer.`);
}

// UI components module
if (componentCount > 0 && lowerDir.includes('component')) {
  parts.push(`A library of reusable UI components that the pages are built from.`);
  parts.push(`Contains ${compNames.length} components: ${compNames.slice(0, 5).join(', ')}...`);
  parts.push(`These handle individual pieces of the interface like buttons, panels, cards, and visualizations.`);
}

// Integrations module
if (lowerDir.includes('integration') || lowerDir.includes('plugin')) {
  parts.push(`Handles connections to external tools and services.`);
  if (externalServices.length > 0) {
    parts.push(`Integrates with: ${externalServices.join(', ')}.`);
  }
  parts.push(`Each integration can be configured with API credentials and provides data to the rest of the application.`);
}
```

Each module gets both a **full description** (2-4 sentences) and a **short description** (one-liner for graph nodes).

### Edge Label Generation

The `generateEdgeLabel()` function creates relationship descriptions between modules:

```typescript
export function generateEdgeLabel(
  sourceModule: SystemModule,
  targetModule: SystemModule,
  importNames: string[],
): string
```

Examples:
- Routes → Server: "handles API requests"
- Server → Data Layer: "stores data using"
- UI Views → Components: "renders UI with"
- Components → Hooks: "uses shared logic from"
- Integrations → External Services: "connects to"

### Current Scan Stats

As of the last scan (2026-02-08):

| Metric | Value |
|--------|-------|
| **Total Files** | 96 |
| **Total Lines** | 19,107 |
| **Functions** | 49 |
| **Components** | 28 |
| **API Routes** | 22 |
| **Pages** | 13 |
| **External Services** | 8 |

**File type breakdown:**
- other: 36
- api_route: 22
- page: 13
- component: 9
- utility: 9
- schema: 3
- config: 3
- hook: 1

**Modules detected:** 11 (Server Ai, Server Routes, UI Views, Server, Server Integrations, UI Components, UI, Scripts, CLI, Shared)

**External services detected:** openai, anthropic, helicone, github, cloudflare, sentry, vercel, deepgram

---

## API Endpoints

The scanner's data is exposed through a Hono API router at `server/routes/codebase.ts`:

### POST /api/v1/codebase/scan

Triggers a fresh scan of the project.

**Request body:**
```json
{
  "project_root": "/path/to/project",  // optional, defaults to current project
  "src_dir": "server"                  // optional, scan only a subdirectory
}
```

**Response:**
```json
{
  "ok": true,
  "data": {
    "stats": { "total_files": 96, "total_lines": 19107, ... },
    "scanned_at": "2026-02-08T04:19:06.358Z",
    "duration_ms": 1523
  }
}
```

Results are cached in `data/codebase/analysis.json`.

### GET /api/v1/codebase/stats

Returns high-level statistics from the last scan.

### GET /api/v1/codebase/files

Returns all files with metadata. Supports filtering:
- `?type=component` — filter by file type
- `?search=auth` — search file paths and export names

### GET /api/v1/codebase/files/:path

Returns detailed information for a specific file:
- Full metadata (exports, imports, external calls, DB operations)
- **Imported by** — files that import this file
- **Depends on** — files this file imports

### GET /api/v1/codebase/modules

Returns all inferred modules with descriptions, file lists, exports, and dependencies.

### GET /api/v1/codebase/routes

Returns all detected API routes with methods and handlers.

### GET /api/v1/codebase/pages

Returns all detected pages with component trees.

### GET /api/v1/codebase/services

Returns external service usage aggregated across all files.

### GET /api/v1/codebase/dependencies

Returns dependency graph edges (file-to-file import relationships).

**Query params:**
- `?file=path/to/file.ts` — filter edges for a specific file

### GET /api/v1/codebase/graph

Returns pre-computed graph data for react-flow visualization.

**Query params:**
- `?view=modules|files|routes` — which graph view to generate (default: modules)
- `?module=ModuleName` — filter to a specific module

**Response structure:**
```json
{
  "ok": true,
  "data": {
    "nodes": [
      {
        "id": "Server Routes",
        "type": "moduleNode",
        "data": {
          "label": "Server Routes",
          "kind": "backend",
          "lines": 3421,
          "exports": 0,
          "files": 22,
          "services": ["helicone", "openai"],
          "description": "This module handles all the HTTP API endpoints...",
          "shortDescription": "Handles API requests for 22 endpoints",
          "keyExports": [],
          "fileTypeSummary": { "api_route": 22 }
        }
      }
    ],
    "edges": [
      {
        "id": "Server Routes->Server",
        "source": "Server Routes",
        "target": "Server",
        "data": {
          "imports": [],
          "label": "handles API requests",
          "relationship": "handles API requests"
        }
      }
    ]
  }
}
```

---

## Codebase Visualizer

**Location:** `ui/src/views/CodebaseGraph.tsx`, `ui/src/views/Codebase.tsx`  
**Tech stack:** React, react-flow, dagre (auto-layout), Tailwind CSS  
**Dependencies:** reactflow, dagre

### Three Graph Views

The visualizer provides three complementary views of the codebase:

#### 1. Module Architecture (Default)

**Purpose:** High-level system overview for non-developers

**Nodes:** System modules (Server Routes, UI Views, Server Integrations, etc.)  
**Node type:** `moduleNode` — large cards with short description, file count, line count, services used  
**Edges:** Module-to-module dependencies with plain-English relationship labels  
**Layout:** Dagre hierarchical (top-to-bottom)

**What you see:**
- Module name and type badge (backend, frontend, integration, data, shared)
- Short description (e.g., "Handles API requests for 22 endpoints")
- File count and total lines
- External services used (GitHub, Helicone, OpenAI, etc.)

**Detail panel:** Click a module to see:
- Full plain-English description
- Stats breakdown (files, lines, exports)
- File type composition (22 api_route, 5 utility, etc.)
- Key exports (most important functions/components)
- Connections with relationship labels (incoming/outgoing)
- External services used

#### 2. File Dependencies

**Purpose:** Technical view of import relationships

**Nodes:** Individual files  
**Node type:** `fileNode` — compact cards with file type, line count, export count  
**Edges:** Import relationships with imported symbol names  
**Layout:** Dagre hierarchical

**What you see:**
- File name and type badge
- Line count and export count
- External service usage indicator

**Detail panel:** Click a file to see:
- Full file metadata
- All exports (functions, components, hooks, classes, types)
- All imports (with source paths)
- External API calls (with line numbers)
- Database operations
- Imported by / Depends on lists

#### 3. API Route Map

**Purpose:** API endpoint visualization

**Nodes:** API routes  
**Node type:** `routeNode` — cards with HTTP method badges and route paths  
**Edges:** Route-to-handler relationships  
**Layout:** Dagre hierarchical

**What you see:**
- HTTP methods (GET, POST, PATCH, DELETE) with color-coded badges
- Route path (e.g., `/api/v1/codebase/scan`)
- Handler file

### Custom Components

#### GraphNode.tsx

Defines four node types:

**ModuleNode:**
- Large card (180-240px wide, 110px tall)
- Kind badge (backend/frontend/integration/data/shared)
- Module name
- Short description (2 lines, line-clamped)
- Stats row (files, lines)
- Service badges (max 3 visible)
- Highlighted/dimmed states for click-to-focus

**FileNode:**
- Compact card (140-180px wide, 70px tall)
- File type badge
- File name (truncated)
- Stats (lines, exports)
- External service count indicator

**RouteNode:**
- Medium card (160-200px wide)
- HTTP method badges (color-coded: GET=green, POST=blue, PATCH=yellow, DELETE=red)
- Route path (monospace font)

**ServiceNode:**
- Pill shape (rounded-full)
- Service name (e.g., "openai", "github")
- Yellow accent color

**Styling system:**
```typescript
const KIND_STYLES: Record<string, { bg: string; border: string; badge: string }> = {
  backend: { bg: 'bg-accent-blue/5', border: 'border-accent-blue/30', badge: 'bg-accent-blue/15 text-accent-blue' },
  frontend: { bg: 'bg-accent-purple/5', border: 'border-accent-purple/30', badge: 'bg-accent-purple/15 text-accent-purple' },
  integration: { bg: 'bg-accent-yellow/5', border: 'border-accent-yellow/30', badge: 'bg-accent-yellow/15 text-accent-yellow' },
  data: { bg: 'bg-accent-green/5', border: 'border-accent-green/30', badge: 'bg-accent-green/15 text-accent-green' },
  shared: { bg: 'bg-accent-cyan/5', border: 'border-accent-cyan/30', badge: 'bg-accent-cyan/15 text-accent-cyan' },
};
```

#### GraphEdge.tsx

Custom edge component with hover tooltips:

**Features:**
- Bezier curve paths
- Invisible wide path for easier hover detection (20px stroke width)
- Hover state changes color to blue
- **Persistent relationship label** when edge is highlighted (click-to-focus)
- **Hover tooltip** showing:
  - Plain-English relationship description
  - Technical detail: imported symbol names (max 6 visible)

**Example tooltip:**
```
handles API requests
─────────────────
3 imports:
[getStore] [broadcast] [startWatcher]
```

#### NodeDetailPanel.tsx

Rich detail panel that slides in from the right when a node is clicked:

**For modules:**
- Full description (2-4 sentences)
- Stats grid (files, lines, exports)
- File type breakdown with badges
- Key exports list
- Connections section with relationship labels (incoming/outgoing)
- External services used
- Hint text for switching views

**For files:**
- File metadata
- All exports with kind badges
- All imports (grouped by external/local)
- External API calls with line numbers
- Database operations
- Imported by / Depends on sections

### Click-to-Highlight Interaction

**Behavior:**
1. Click any node → highlights that node and all its direct connections
2. Connected nodes: highlighted (full opacity, blue ring)
3. Unconnected nodes: dimmed (20% opacity)
4. Connected edges: highlighted, animated, show relationship label
5. Unconnected edges: dimmed
6. Click the same node again → clears highlights
7. Click pane (background) → clears highlights

**Implementation:**
- Nodes have `highlighted` and `dimmed` boolean flags in their data
- Edges have `highlighted`, `dimmed`, and `animated` flags
- Click handler updates all nodes/edges in one pass

### Dagre Auto-Layout

The `getLayoutedElements()` function uses dagre for automatic graph layout:

```typescript
function getLayoutedElements(
  nodes: Node<GraphNodeData>[],
  edges: Edge<GraphEdgeData>[],
  direction: 'TB' | 'LR' = 'TB',
)
```

**Configuration:**
- **rankdir:** 'TB' (top-to-bottom) or 'LR' (left-to-right)
- **nodesep:** 60px (horizontal spacing between nodes)
- **ranksep:** 80px (vertical spacing between ranks)
- **edgesep:** 20px (minimum edge separation)

**Node size estimation:**
- ModuleNode: 220×110
- FileNode: 160×70
- RouteNode: 180×80
- ServiceNode: 100×36

### Codebase.tsx Wrapper

The `Codebase.tsx` view wraps `CodebaseGraph` with additional features:

**Tabs:**
- **Architecture** — CodebaseGraph component (module view)
- **Overview** — Stats dashboard with file type breakdown
- **Files** — Filterable file list with type filter
- **Pages** — List of all page routes
- **API Routes** — List of all API endpoints with methods
- **Modules** — List of all modules with expandable details
- **External Services** — Service usage aggregation

**Top bar:**
- Last scan timestamp
- "Scan Project" button (triggers fresh scan)

**Search:**
- Searches across files, functions, routes, components
- Live search results with entity type badges
- Min 2 characters to trigger

---

## AI Tool Integration

The codebase scanner is exposed to DevTrack's AI chat agent through tools:

### get_codebase_stats

Returns high-level statistics (files, lines, functions, components, routes, pages, services).

### get_modules

Returns all modules with descriptions, files, exports, dependencies, services.

### search_codebase

Searches across files, functions, routes, pages by query string.

### get_file_details

Returns detailed information for a specific file (exports, imports, dependencies).

### scan_codebase

Triggers a fresh scan. Takes optional `src_dir` parameter to scan a subdirectory.

These tools enable the AI to:
- Answer questions about codebase structure ("What does the Server Routes module do?")
- Find specific files or functions ("Where is the authentication logic?")
- Understand dependencies ("What files import the scanner?")
- Generate architecture documentation

---

## Known Issues

### ISS-007 (Resolved)

**Issue:** Architecture graph was meaningless to non-developers — nodes showed file counts but no explanation of what modules do.

**Fix:** Built `generateModuleDescription()` and `generateEdgeLabel()` to create plain-English descriptions from code analysis. Module nodes now show short descriptions. Detail panel shows full descriptions, stats, file type breakdown, key exports, and connections with relationship labels.

### Future Enhancements

**From the ideas backlog:**

- **IDEA-017 (validated):** Zero-annotation architecture inference — already implemented as the core design philosophy
- **Module health scoring:** Infer health from test coverage, error handling patterns, TODO density
- **Dependency risk analysis:** Detect circular dependencies, highlight high-coupling modules
- **Change impact visualization:** Show which modules are affected by a file change
- **Historical analysis:** Track module growth, complexity trends over time
- **Cross-project comparison:** Compare architecture patterns across multiple projects

---

## Performance Characteristics

**Scan speed:** ~1.5 seconds for 96 files (19K lines)  
**Memory usage:** Entire analysis cached in memory (~2-5 MB JSON)  
**Incremental scans:** Not yet implemented — every scan is full  
**Cache invalidation:** Manual (click "Scan Project" button)

**Scalability limits:**
- Tested up to ~100 files
- Expected to handle 500-1000 files without performance issues
- Large monorepos (5000+ files) may need incremental scanning

---

## File Locations

**Scanner:**
- `server/analyzer/scanner.ts` — Main scanner logic (878 lines)

**API:**
- `server/routes/codebase.ts` — Hono API router (418 lines)

**Visualizer:**
- `ui/src/views/CodebaseGraph.tsx` — Main graph view (307 lines)
- `ui/src/views/Codebase.tsx` — Wrapper with tabs (411 lines)
- `ui/src/components/graph/GraphNode.tsx` — Custom node components (164 lines)
- `ui/src/components/graph/GraphEdge.tsx` — Custom edge component (125 lines)
- `ui/src/components/graph/NodeDetailPanel.tsx` — Detail panel (486 lines)

**Data:**
- `data/codebase/analysis.json` — Cached scan results

**AI Tools:**
- `server/ai/tools/codebase.ts` — AI tool definitions

---

## Related Documentation

- **System: AI Intelligence Layer** — Uses codebase data for context
- **System: Data Layer** — Stores scan results
- **API Reference** — Full endpoint documentation
- **IDEA-017** — Zero-annotation architecture inference (validated)

---

## Usage Examples

### Scan from CLI

```bash
# Scan current project
curl -X POST http://localhost:3456/api/v1/codebase/scan

# Scan subdirectory
curl -X POST http://localhost:3456/api/v1/codebase/scan \
  -H "Content-Type: application/json" \
  -d '{"src_dir": "server"}'
```

### Get module information

```bash
curl http://localhost:3456/api/v1/codebase/modules | jq
```

### Search codebase

```bash
curl http://localhost:3456/api/v1/codebase/search?q=authentication
```

### Ask AI about architecture

In DevTrack chat:
```
"What does the Server Integrations module do?"
"Show me all files that use the OpenAI API"
"What are the key exports from the UI Components module?"
```

---

**Last updated:** 2026-02-09  
**Health score:** 80/100 (both scanner and visualizer)  
**Status:** ✅ Production-ready with known enhancement opportunities