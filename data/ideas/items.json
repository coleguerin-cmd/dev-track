{
  "ideas": [
    {
      "id": "IDEA-001",
      "title": "Structured code annotations for codebase explorer",
      "description": "A doc-comment format the tool can parse (like JSDoc but for dev-track — @dt-description, @dt-depends, @dt-external) that feeds into the Codebase Explorer. AI writes these as it develops, tool parses them for rich tooltips and explanations. Not just basic commenting — structured metadata the tool understands.",
      "category": "feature",
      "status": "captured",
      "source": "conversation 2026-02-07 (ideas thread)",
      "related_ideas": ["IDEA-002", "IDEA-003"],
      "promoted_to": null,
      "pros": ["Non-engineers can understand codebase via tooltips", "AI maintains them as it writes code", "Parseable structured data, not freeform comments"],
      "cons": ["Adds noise to source files", "AI has to be disciplined about maintaining them", "Need to define a spec for the annotation format"],
      "open_questions": ["What annotation format? JSDoc-like? Magic comments?", "How do we handle annotation drift when code changes?", "Do we parse on scan or in real-time?"],
      "notes": "Requires the Codebase Explorer to be working and useful first so we know what annotations actually matter. Phase 3+.",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    },
    {
      "id": "IDEA-002",
      "title": "Initialization wizard with AI-powered project analysis",
      "description": "When dev-track is added to a new project, an initialization flow where the AI scans the codebase, infers the project structure, writes initial state.json (system ratings), captures TODOs/FIXMEs as backlog items, generates a context recovery briefing, and verifies the tool reflects the project status accurately.",
      "category": "feature",
      "status": "captured",
      "source": "conversation 2026-02-07 (ideas thread)",
      "related_ideas": ["IDEA-003"],
      "promoted_to": null,
      "pros": ["Zero-to-productive in one command", "AI does the heavy lifting of understanding the project", "Verifiable win condition"],
      "cons": ["Quality depends on model capability", "Large codebases may need chunked analysis", "Without good existing docs, AI analysis is limited"],
      "open_questions": ["How to handle projects with zero documentation?", "Multi-pass for smaller models — how to chunk?", "What's the minimum viable initialization?"],
      "notes": "The codebase scanner already does 80% of this.",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    },
    {
      "id": "IDEA-003",
      "title": "Multi-model support with context-aware budgeting",
      "description": "Different AI models have different context windows and costs. dev-track should adapt: Opus with 1M context gets the full story, GPT-4o-mini gets a compressed version, smaller models get just the Quick Status + Now items.",
      "category": "architecture",
      "status": "captured",
      "source": "conversation 2026-02-07 (ideas thread)",
      "related_ideas": ["IDEA-002"],
      "promoted_to": null,
      "pros": ["Works for everyone regardless of model/budget", "Prevents context overflow on smaller models", "Cost-conscious by default"],
      "cons": ["Harder to test across all model sizes", "Compression may lose important nuance"],
      "open_questions": ["Auto-detect model or manual config?", "Should we have preset profiles (heavy/medium/light)?"],
      "notes": "The verbosity settings already exist in config. This extends them with model-aware profiles.",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    },
    {
      "id": "IDEA-004",
      "title": "dev-track as an open-source product",
      "description": "Open-source the file format + cursor rule + basic UI. File format becoming a standard is more valuable than the tool itself.",
      "category": "business",
      "status": "exploring",
      "source": "conversation 2026-02-07 (ideas thread)",
      "related_ideas": [],
      "promoted_to": null,
      "pros": ["Growing market of AI-assisted developers", "No existing tool solves this exact problem", "Open-source builds community and adoption"],
      "cons": ["Small TAM right now", "Core file format is easily replicated", "Needs real usage validation first"],
      "open_questions": ["When to extract? After how much dogfooding?", "License: MIT? Apache? AGPL?"],
      "notes": "Dogfood for 2-3 weeks. Extract when the data model is stable and the UI is polished.",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    },
    {
      "id": "IDEA-005",
      "title": "Codebase visualization with interactive diagrams",
      "description": "Interactive diagrams: dependency graphs (react-flow), page-to-API-to-DB flow charts, call trees. Click a node to see details. Hover for tooltips. Filter by module/system. Layman-friendly architecture explorer.",
      "category": "feature",
      "status": "promoted",
      "source": "conversation 2026-02-07 (ideas thread)",
      "related_ideas": ["IDEA-001"],
      "promoted_to": "codebase-visualizer",
      "pros": ["Visual understanding of complex codebases", "Non-engineers can navigate architecture", "Impressive demo for open-source launch"],
      "cons": ["react-flow adds complexity", "Layout algorithms for large graphs are hard"],
      "open_questions": [],
      "notes": "BUILDING NOW. Using react-flow + dagre. Three views: module architecture, file dependencies, API route map.",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    },
    {
      "id": "IDEA-006",
      "title": "Always-on diagnostic triggers",
      "description": "Post-deploy hooks (Vercel webhook), Sentry webhook auto-create issues, cron-based health checks. Tool surfaces problems before the user even opens it.",
      "category": "architecture",
      "status": "captured",
      "source": "conversation 2026-02-07 (ideas thread)",
      "related_ideas": [],
      "promoted_to": null,
      "pros": ["Catches problems automatically", "AI starts sessions with real-time awareness"],
      "cons": ["Requires dev-track server running", "Webhook setup is project-specific"],
      "open_questions": ["Local-only or need a cloud relay?", "Queue system needed?"],
      "notes": "Phase 4+. Requires working integrations first.",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    },
    {
      "id": "IDEA-007",
      "title": "Background AI agents for R&D, docs, design iteration",
      "description": "Lightweight agents that run against dev-track data. R&D agent explores ideas. Docs agent keeps documentation in sync. Design agent iterates mockups. Run on triggers or schedules, not in the IDE.",
      "category": "architecture",
      "status": "captured",
      "source": "conversation 2026-02-07 (ideas thread)",
      "related_ideas": ["IDEA-006"],
      "promoted_to": null,
      "pros": ["Work happens even when user isn't coding", "Separates concerns"],
      "cons": ["Complex orchestration", "Cost if running frequently"],
      "open_questions": ["Claude Code CLI as the agent runtime?", "How to trigger — schedule vs event?"],
      "notes": "Far future. The data layer supports it — agents just read/write data/ files.",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    },
    {
      "id": "IDEA-008",
      "title": "Web-based multi-user version with concurrent sessions",
      "description": "Multiple users working concurrently with their own conversation threads. Sessions as first-class entities. API server handles serialization. Auth, permissions, activity attribution.",
      "category": "architecture",
      "status": "captured",
      "source": "conversation 2026-02-07 (session 2)",
      "related_ideas": ["IDEA-004", "IDEA-007"],
      "promoted_to": null,
      "pros": ["Future-proofs for team usage", "API server already exists as coordination layer"],
      "cons": ["Significant architectural lift", "File-based store may not scale"],
      "open_questions": ["When does file-based storage hit its limit?", "How to handle auth?"],
      "notes": "Plant seeds in data model now. Build when local tool is fully validated.",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    },
    {
      "id": "IDEA-009",
      "title": "Integration data routing into native views",
      "description": "Instead of a flat integrations tab, route integration data into relevant views: Sentry errors flow into Issues as a separate section, Helicone costs into a Costs tab, Vercel deploys into a Deploys section on Dashboard. Each integration populates the view where its data is most useful.",
      "category": "feature",
      "status": "captured",
      "source": "conversation 2026-02-07 (session 3)",
      "related_ideas": ["IDEA-006"],
      "promoted_to": null,
      "pros": ["Data appears where it's contextually relevant", "Reduces tab switching", "Makes integrations feel native not bolted-on"],
      "cons": ["Complex routing logic per integration", "Need to handle missing integrations gracefully", "Each view needs integration-aware sections"],
      "open_questions": ["How to handle when integration is down vs not configured?", "Do we need a separate Costs tab or just sections?"],
      "notes": "Start with Sentry -> Issues and Helicone -> Metrics. Build the pattern, then extend.",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    },
    {
      "id": "IDEA-010",
      "title": "Global command-P style search across all data",
      "description": "Floating search bar at the top of every page (or hotkey-activated) that searches across backlog items, issues, ideas, changelog entries, codebase files, brain notes. Like Cursor's command palette but for dev-track data. Results grouped by type with quick-jump to the item.",
      "category": "ux",
      "status": "captured",
      "source": "conversation 2026-02-07 (session 3)",
      "related_ideas": [],
      "promoted_to": null,
      "pros": ["Fast navigation", "Discoverability of old items", "Feels professional and powerful"],
      "cons": ["Need a unified search index or multi-source search", "Performance if data grows large"],
      "open_questions": ["Server-side search or client-side?", "Hotkey activation or always-visible?"],
      "notes": "Codebase Explorer already has search within its view. This extends it globally.",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    },
    {
      "id": "IDEA-011",
      "title": "UI design overhaul — Cursor-inspired minimalism",
      "description": "Full design pass: replace emoji icons with clean SVG/Lucide icons, tighter spacing, better typography hierarchy, Cursor-inspired sidebar navigation. More professional, less playful. The goal is clean information density like Linear or Cursor's dashboard.",
      "category": "ux",
      "status": "captured",
      "source": "conversation 2026-02-07 (session 3)",
      "related_ideas": [],
      "promoted_to": null,
      "pros": ["More professional appearance", "Better information density", "Consistent with tools developers already use"],
      "cons": ["Significant effort across all 11 views", "Subjective — need to nail the aesthetic"],
      "open_questions": ["Which icon set? Lucide is already installed.", "How far to deviate from current dark theme?"],
      "notes": "User specifically mentioned liking Cursor's navigation style. Lucide-react is already in package.json.",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    },
    {
      "id": "IDEA-012",
      "title": "Expanded descriptions and rich detail panels",
      "description": "Backlog items, issues, and ideas should support expanded descriptions — markdown-capable, with more context than a one-liner. Detail panels should show full context when clicked/expanded.",
      "category": "ux",
      "status": "captured",
      "source": "conversation 2026-02-07 (session 3)",
      "related_ideas": ["IDEA-011"],
      "promoted_to": null,
      "pros": ["More context per item", "Reduces need to read raw JSON", "Better for handoffs"],
      "cons": ["More data to manage", "UI gets busier if not done well"],
      "open_questions": ["Markdown rendering or plain text?", "Inline expansion or slide-out panel?"],
      "notes": "react-markdown is already in package.json. Could render descriptions as markdown in detail panels.",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    },
    {
      "id": "IDEA-013",
      "title": "Costs and observability dashboard",
      "description": "Cross-integration cost monitoring: Helicone for AI costs, Vercel for compute/bandwidth, Supabase for DB usage, Cursor spending. A unified costs view showing burn rate across all services.",
      "category": "feature",
      "status": "captured",
      "source": "conversation 2026-02-07 (session 3)",
      "related_ideas": ["IDEA-009"],
      "promoted_to": null,
      "pros": ["Single pane of glass for all costs", "Could alert on spending spikes", "Useful for budget-conscious developers"],
      "cons": ["Every provider has different billing APIs", "Some don't expose cost data via API"],
      "open_questions": ["Which providers expose cost APIs?", "Manual entry fallback for those that don't?"],
      "notes": "User showed $733 Cursor spend in screenshot. Cost awareness is clearly important to them.",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    }
    ,
    {
      "id": "IDEA-014",
      "title": "Background AI watcher — file-change-driven intelligence loop",
      "description": "A lightweight AI process that monitors the codebase for file changes in real-time. On change: analyze what changed, auto-update changelog, detect if backlog/issues/state need updating, and do it. Doesn't write code — just observes and tracks. Could use cheap models (GPT-4o-mini, Haiku) since it's analysis not generation. Runs alongside the coding AI, communicates via dev-track data files. The coding AI in Cursor/Claude leaves notes, the watcher AI picks them up and maintains the tracking system.",
      "category": "architecture",
      "status": "captured",
      "source": "conversation 2026-02-07 (session 3 — meta discussion)",
      "related_ideas": ["IDEA-007", "IDEA-006"],
      "promoted_to": null,
      "pros": ["Removes human-in-the-loop for tracking", "Removes coding-AI attention burden for tracking", "Cheap models sufficient for analysis-only work", "File watcher already exists (chokidar)", "Data layer is the communication protocol between AIs", "Could stream-analyze changes as they come in"],
      "cons": ["Cost adds up if triggered on every save", "Needs debouncing — 20 file changes in one prompt shouldn't trigger 20 analyses", "Needs to understand 'when the AI is done' vs mid-edit", "Context window still needed to understand changes meaningfully"],
      "open_questions": ["What model? GPT-4o-mini? Haiku? Local model?", "Trigger on git commit? On file save with debounce? On session end?", "How does the coding AI signal 'I just finished a task' to the watcher?", "Can we use git diff as the input rather than raw file watching?"],
      "notes": "This is the real solution to the 'AI forgot to update changelog' problem. Instead of asking the coding AI to both write code AND track changes (competing attention), separate the concerns: coding AI writes code, watcher AI tracks changes. They communicate through dev-track data files — that's the protocol. Start simple: on git commit, run a cheap model against the diff and auto-update changelog + state.",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    },
    {
      "id": "IDEA-015",
      "title": "Layman-friendly module descriptions and relationship explanations",
      "description": "The architecture graph currently shows technical labels (Server, Server Routes) with no explanation of what they are or why they connect. A layman sees 'Server' and doesn't know it's a Hono HTTP server handling API requests. Each module needs a plain-English description auto-generated from its contents. Edges need explanations beyond 'imports X' — they should say 'Server Routes handles API requests and stores data using the Data Store.' Think Wikipedia summary, not JSDoc.",
      "category": "ux",
      "status": "captured",
      "source": "conversation 2026-02-07 (session 3 — graph feedback)",
      "related_ideas": ["IDEA-005", "IDEA-001"],
      "promoted_to": null,
      "pros": ["Makes the graph actually useful for non-developers", "Differentiates dev-track from every other code visualization tool", "AI-generated descriptions can be very good"],
      "cons": ["Auto-generation quality varies", "Needs to stay in sync as code changes", "Long descriptions clutter the graph"],
      "open_questions": ["Generate at scan time or on-demand?", "Where to show: on the node, in the panel, or both?", "How to handle modules where auto-description would be vague?"],
      "notes": "The scanner has all the data — file types, exports, external services, DB ops. We can generate descriptions like: 'This module handles all HTTP API requests. It has 16 route files covering backlog, issues, sessions, metrics, and more. It depends on the Data Store for persistence and broadcasts changes via WebSocket.' The detail panel should show this prominently.",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    }
    ,
    {
      "id": "IDEA-016",
      "title": "Living project wiki with auto-generated documentation",
      "description": "The Docs tab should be a full end-to-end wiki and source of truth for whatever project you're building. It should auto-update when architecture changes: new modules get documented, API changes get reflected, component libraries get cataloged. Think of it as a self-maintaining knowledge base that could onboard a new AI or developer to the project. Phase 1 (markdown rendering, ToC, nav) is built. Phase 2 needs: auto-doc generation from codebase scans, cross-references between docs and code, search within docs, and richer navigation with nested sections.",
      "category": "feature",
      "status": "exploring",
      "source": "conversation 2026-02-07 (session 4)",
      "related_ideas": ["IDEA-001", "IDEA-015"],
      "promoted_to": "docs-wiki-overhaul",
      "pros": ["Single source of truth for the project", "Auto-updates reduce manual maintenance", "Onboarding tool for new AIs and developers", "Beautiful rendered markdown instead of raw files"],
      "cons": ["Auto-generation quality may vary", "Need to handle multiple doc formats", "Could get stale if auto-update breaks"],
      "open_questions": ["Should docs be markdown or HTML?", "How to auto-detect when architecture changed enough to trigger doc update?", "How to handle docs for external project (not dev-track itself)?"],
      "notes": "User specifically wants: nested tabs/nav, table of contents with sections within sections, beautiful rendering, real-time updates on architecture changes. Look at Pillar project docs for reference on structure. Phase 1 shipped: react-markdown + remark-gfm rendering, file sidebar, auto-generated ToC, styled components for all markdown elements.",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    },
    {
      "id": "IDEA-017",
      "title": "Scanner-driven code understanding — no special comments needed",
      "description": "Instead of requiring the coding AI to write special annotations (@dt-description etc.), make the scanner smart enough to understand code from its existing structure. The scanner already has file types, exports, imports, function signatures, external services, and DB operations. From this, it can generate plain-English descriptions. The background watcher (IDEA-014) should analyze git diffs holistically (full commits) rather than individual file changes, so it gets context. This sidesteps the 'who writes the comments' and 'different comment syntax per language' problems entirely.",
      "category": "architecture",
      "status": "validated",
      "source": "conversation 2026-02-07 (session 4 — architecture discussion)",
      "related_ideas": ["IDEA-001", "IDEA-014", "IDEA-015"],
      "promoted_to": null,
      "pros": ["No code pollution with special comments", "Works across all languages", "Code IS the source of truth", "Already proven — module descriptions work well", "Background watcher gets context from git diffs not file saves"],
      "cons": ["Auto-generated descriptions can be generic for unusual modules", "Requires good heuristics per module type"],
      "open_questions": ["Should we add optional manual override for auto-descriptions?", "How to handle projects with unusual structures?"],
      "notes": "This was validated in session 4. The generateModuleDescription() function produces descriptions like 'This module handles all the HTTP API endpoints for the application. It contains 16 route files covering...' — far better than any annotation system could produce because it has the full module context. IDEA-001 (structured annotations) is now deprioritized in favor of this approach.",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    }
    ,
    {
      "id": "IDEA-018",
      "title": "Helicone deep integration — sessions, properties, users, cache",
      "description": "Go beyond basic proxy: use Helicone Sessions to group multi-turn conversations, Properties for tagging by feature/task type, Users for per-user cost attribution, and Cache for identical prompt deduplication. Admin-level dashboard showing cost by feature, by user, by model. Critical for both dogfooding and eventual multi-tenant billing.",
      "category": "integration",
      "status": "captured",
      "source": "conversation 2026-02-07 (session 4)",
      "related_ideas": ["IDEA-013"],
      "promoted_to": null,
      "pros": ["Granular cost visibility", "Caching saves money on repeated prompts", "Per-user tracking essential for teams", "Audit trail for AI decisions"],
      "cons": ["Adds Helicone as a hard dependency for analytics", "Configuration complexity"],
      "open_questions": ["Should we build our own analytics or rely on Helicone?", "How to handle when Helicone is down?"],
      "notes": "User set up BYOK in Helicone. Ready to integrate deeply.",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    },
    {
      "id": "IDEA-019",
      "title": "Rich tool call tray — Pillar-style expandable elements with navigation",
      "description": "The chat tool calls should render as rich, interactive elements. Click a backlog item result to navigate to the Backlog view with that item highlighted. Click an issue to jump to Issues. Show clear icons per tool type, expandable results with formatted data, and persistent chat context while navigating. Pull from Pillar's tray system implementation.",
      "category": "ux",
      "status": "captured",
      "source": "conversation 2026-02-07 (session 4)",
      "related_ideas": ["IDEA-005"],
      "promoted_to": null,
      "pros": ["Makes tool calls actionable not just informational", "Chat becomes a navigation hub", "Feels like a real agent not just a chatbot"],
      "cons": ["Significant UI complexity", "Need to coordinate chat state with view navigation"],
      "open_questions": ["How to handle navigation while chat is mid-stream?", "Which tools get rich rendering vs plain text?"],
      "notes": "Reference: Pillar's SidebarChat tray system and Landmark's ToolCallDisplay component.",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    },
    {
      "id": "IDEA-020",
      "title": "Self-hosted logging for dev-track-on-dev-track (vindaloop)",
      "description": "dev-track building dev-track. All AI calls, tool executions, errors, and performance data logged internally. A dedicated Logs view in the UI showing request/response pairs, latencies, costs, errors. This data feeds back into the dev-track AI so it can help debug itself. The ultimate dogfooding loop.",
      "category": "architecture",
      "status": "captured",
      "source": "conversation 2026-02-07 (session 4)",
      "related_ideas": ["IDEA-014", "IDEA-018"],
      "promoted_to": null,
      "pros": ["Eat your own dogfood at every level", "AI can help debug AI issues", "Proves the tool works on complex real projects"],
      "cons": ["Recursive complexity", "Log volume could get large"],
      "open_questions": ["Store logs in data/ai/logs/ or a separate system?", "How much context does the AI need about its own logs?"],
      "notes": "The vindaloop. dev-track monitors itself building itself. This is actually a killer demo for the product.",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    },
    {
      "id": "IDEA-021",
      "title": "Distribution model — lightweight local daemon + web platform",
      "description": "How to make dev-track a paid product. The local tool (daemon) handles: file watching, git monitoring, codebase scanning, context generation. The web platform handles: UI, AI chat, team features, billing, cross-project dashboards, admin. Daemon syncs to web via API. Web works without daemon (reduced features) or with it (full power). npm install for try-it, web platform for paid experience.",
      "category": "business",
      "status": "exploring",
      "source": "conversation 2026-02-07 (session 4)",
      "related_ideas": ["IDEA-004", "IDEA-008"],
      "promoted_to": null,
      "pros": ["Preserves local-first real-time advantage", "Web handles auth/billing/teams", "npm distribution for easy trial", "Proven model (Cursor, Copilot, Linear)"],
      "cons": ["Building both a daemon AND a web platform", "Sync reliability between local and cloud", "Offline mode complexity"],
      "open_questions": ["Electron/Tauri desktop app vs pure daemon?", "Free tier scope?", "How to handle multi-project views?", "GitHub App integration as alternative entry point?"],
      "notes": "See detailed analysis in session 4 conversation. Multiple distribution options explored: desktop app, CLI, IDE extension, GitHub App, hybrid daemon+web. Hybrid wins because it preserves what makes dev-track unique (local real-time context) while enabling what requires cloud (teams, billing, AI budget).",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    },
    {
      "id": "IDEA-022",
      "title": "Users, teams, auth, billing, multi-tenant RLS",
      "description": "The full multi-user stack: user accounts, team workspaces, role-based access, Stripe billing, row-level security for multi-tenant data. Required for paid product but NOT required for v0.1 dogfooding. Backlog this until the core product is validated.",
      "category": "architecture",
      "status": "captured",
      "source": "conversation 2026-02-07 (session 4)",
      "related_ideas": ["IDEA-008", "IDEA-021"],
      "promoted_to": null,
      "pros": ["Required for revenue", "Teams is a force multiplier for the product"],
      "cons": ["Massive engineering scope", "Premature if core product isn't validated"],
      "open_questions": ["Supabase Auth or custom?", "Stripe or Lemon Squeezy?", "When to start — after how much dogfooding?"],
      "notes": "User correctly identified this as a can of worms. Park until v0.2+.",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    }
    ,
    {
      "id": "IDEA-023",
      "title": "Visual state capture — automated screenshots of every view for AI context",
      "description": "Dev-track automatically takes screenshots of each view/tab and maintains a visual state library. The AI can reference what the UI actually looks like without the user manually screenshotting. Could use Puppeteer/Playwright headless to capture each route. Stored in data/screenshots/ with timestamps. The chat agent can say 'here's what the dashboard looks like right now.' For development: instant visual feedback loop — AI sees what it built. For product: visual diffs between sessions, UI regression detection, onboarding screenshots.",
      "category": "feature",
      "status": "captured",
      "source": "conversation 2026-02-07 (session 4)",
      "related_ideas": ["IDEA-020"],
      "promoted_to": null,
      "pros": ["AI gets visual context without user effort", "Visual diff detection between versions", "Great for AI-assisted UI iteration", "Kills the constant screenshot-and-paste workflow"],
      "cons": ["Puppeteer/Playwright adds a heavy dependency", "Screenshots need to be taken at the right time", "Storage grows with every capture"],
      "open_questions": ["Headless browser or actual browser automation?", "Trigger: on scan, on demand, on page change?", "How to efficiently diff screenshots?", "Should the chat be able to request a fresh screenshot?"],
      "notes": "User currently does this manually constantly — screenshots to send to AI. Automating it is obvious. Could start simple: just capture on codebase scan and store the images.",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    }
  ],
  "next_id": 24
}
