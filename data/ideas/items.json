{
  "ideas": [
    {
      "id": "IDEA-001",
      "title": "Structured code annotations for codebase explorer",
      "description": "A doc-comment format the tool can parse (like JSDoc but for dev-track — @dt-description, @dt-depends, @dt-external) that feeds into the Codebase Explorer. AI writes these as it develops, tool parses them for rich tooltips and explanations. Not just basic commenting — structured metadata the tool understands.",
      "category": "feature",
      "status": "captured",
      "source": "conversation 2026-02-07 (ideas thread)",
      "related_ideas": ["IDEA-002", "IDEA-003"],
      "promoted_to": null,
      "pros": ["Non-engineers can understand codebase via tooltips", "AI maintains them as it writes code", "Parseable structured data, not freeform comments"],
      "cons": ["Adds noise to source files", "AI has to be disciplined about maintaining them", "Need to define a spec for the annotation format"],
      "open_questions": ["What annotation format? JSDoc-like? Magic comments?", "How do we handle annotation drift when code changes?", "Do we parse on scan or in real-time?"],
      "notes": "Requires the Codebase Explorer to be working and useful first so we know what annotations actually matter. Phase 3+.",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    },
    {
      "id": "IDEA-002",
      "title": "Initialization wizard with AI-powered project analysis",
      "description": "When dev-track is added to a new project, an initialization flow where the AI scans the codebase, infers the project structure, writes initial state.json (system ratings), captures TODOs/FIXMEs as backlog items, generates a context recovery briefing, and verifies the tool reflects the project status accurately. Win condition: every system rated, every TODO captured, AI has context briefing ready.",
      "category": "feature",
      "status": "captured",
      "source": "conversation 2026-02-07 (ideas thread)",
      "related_ideas": ["IDEA-003"],
      "promoted_to": null,
      "pros": ["Zero-to-productive in one command", "AI does the heavy lifting of understanding the project", "Verifiable win condition"],
      "cons": ["Quality depends on model capability", "Large codebases may need chunked analysis", "Without good existing docs, AI analysis is limited"],
      "open_questions": ["How to handle projects with zero documentation?", "Multi-pass for smaller models — how to chunk?", "What's the minimum viable initialization?"],
      "notes": "The codebase scanner already does 80% of this. Initialization would be: scan + AI analysis of scan results + generate initial data files. Could be a CLI command: dev-track init --analyze",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    },
    {
      "id": "IDEA-003",
      "title": "Multi-model support with context-aware budgeting",
      "description": "Different AI models have different context windows and costs. dev-track should adapt: Opus 4.6 with 1M context gets the full story, GPT-4o-mini gets a compressed version, smaller models get just the Quick Status + Now items. Verbosity settings could auto-detect model or be configured per-platform.",
      "category": "architecture",
      "status": "captured",
      "source": "conversation 2026-02-07 (ideas thread)",
      "related_ideas": ["IDEA-002"],
      "promoted_to": null,
      "pros": ["Works for everyone regardless of model/budget", "Prevents context overflow on smaller models", "Cost-conscious by default"],
      "cons": ["Harder to test across all model sizes", "Compression may lose important nuance", "Model detection is tricky (how do we know what model the user is running?)"],
      "open_questions": ["Auto-detect model or manual config?", "What's the minimum useful context for a small model?", "Should we have preset profiles (heavy/medium/light)?"],
      "notes": "The verbosity settings already exist in config. This extends them with model-aware profiles.",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    },
    {
      "id": "IDEA-004",
      "title": "dev-track as an open-source product",
      "description": "Extract dev-track from Pillar into its own repository. Open-source the file format + cursor rule + basic UI. Potentially chargeable features: cloud-hosted version, automated diagnostics, cross-project dashboards, background AI agents. The file format becoming a standard is more valuable than the tool itself.",
      "category": "business",
      "status": "exploring",
      "source": "conversation 2026-02-07 (ideas thread)",
      "related_ideas": [],
      "promoted_to": null,
      "pros": ["Growing market of AI-assisted developers", "No existing tool solves this exact problem", "Open-source builds community and adoption", "File format as protocol is defensible"],
      "cons": ["Small TAM right now", "Core file format is easily replicated", "Needs real usage validation first"],
      "open_questions": ["When to extract? After how much dogfooding?", "What's the minimum for a public v0.1?", "License: MIT? Apache? AGPL?"],
      "notes": "Build within Pillar for context. Dogfood for 2-3 weeks. Extract when the data model is stable and the UI is polished. Name TBD.",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    },
    {
      "id": "IDEA-005",
      "title": "Codebase visualization with interactive diagrams",
      "description": "Beyond the current file/module/route list views — actual interactive diagrams: dependency graphs (react-flow), page→API→DB flow charts, entity relationship diagrams, call trees. Click a node to see the code. Hover for tooltips. Filter by module/system. Neo4j or vector DB not needed — structured JSON from the scanner is enough for visualization.",
      "category": "feature",
      "status": "captured",
      "source": "conversation 2026-02-07 (ideas thread)",
      "related_ideas": ["IDEA-001"],
      "promoted_to": null,
      "pros": ["Visual understanding of complex codebases", "Non-engineers can navigate architecture", "Impressive demo for open-source launch"],
      "cons": ["react-flow or D3 adds complexity", "Layout algorithms for large graphs are hard", "Needs the scanner data to be accurate first"],
      "open_questions": ["react-flow vs D3 vs custom SVG?", "What's the most useful first diagram?", "How to handle 600+ file dependency graphs without visual noise?"],
      "notes": "Start with: API route map (most useful, bounded scope), then page→component tree, then full dependency graph. react-flow is probably the right choice.",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    },
    {
      "id": "IDEA-006",
      "title": "Always-on diagnostic triggers",
      "description": "Post-deploy hooks (Vercel webhook → dev-track), Sentry webhook → auto-create issues, cron-based health checks. The tool surfaces problems before the user even opens it. Next session, AI says 'Sentry caught 3 new errors since your last session.'",
      "category": "architecture",
      "status": "captured",
      "source": "conversation 2026-02-07 (ideas thread)",
      "related_ideas": [],
      "promoted_to": null,
      "pros": ["Catches problems automatically", "AI starts sessions with real-time awareness", "Feels genuinely 'always on'"],
      "cons": ["Requires dev-track server running (or a lightweight cloud endpoint)", "Webhook setup is project-specific", "Could generate noise if not filtered well"],
      "open_questions": ["Local-only or need a cloud relay?", "How to handle webhooks when the server isn't running?", "Queue system needed?"],
      "notes": "Phase 4+. Requires working integrations first.",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    },
    {
      "id": "IDEA-007",
      "title": "Background AI agents for R&D, docs, design iteration",
      "description": "Separate from the coding AI — lightweight agents that run against dev-track data. An R&D agent that explores ideas and writes proposals. A docs agent that keeps documentation in sync with code changes. A design agent that iterates mockups. These run on triggers or schedules, not in the IDE.",
      "category": "architecture",
      "status": "captured",
      "source": "conversation 2026-02-07 (ideas thread)",
      "related_ideas": ["IDEA-006"],
      "promoted_to": null,
      "pros": ["Work happens even when user isn't coding", "Separates concerns (coding AI vs management AI)", "Could use cheaper models for background tasks"],
      "cons": ["Complex orchestration", "Cost if running frequently", "How to surface results without being noisy"],
      "open_questions": ["Claude Code CLI as the agent runtime?", "How to trigger — schedule vs event?", "How do agents communicate findings back?"],
      "notes": "Far future. Requires everything else working first. But the data layer supports it — agents just read/write dev-track/data/ files.",
      "created": "2026-02-07",
      "updated": "2026-02-07"
    }
  ],
  "next_id": 8
}
